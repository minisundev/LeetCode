class Solution {
    public int trailingZeroes(int n) {
        // trailing zero가 나오려면 얘가 일단 10의 배수가 되고 100의 배수가 되고 1000의 배수가 되고 막 이래야 하는데 말이죠?
        // 일단 2와 5가 1번 발생하면 10의 배수가 됨
        // 2와 5가 2번 발생하면 100의 배수가 됨 하하! 이거 그리디네~
        // 10이 곱해지면 5랑 2에 동시에 숫자 체크하면 되는거고 어차피 10씩 올라가는거니까?
        // 걍 5로 나눠서 몫 체크하고 2로 나눠서 몫 체크해서 둘중에 min을 쓰면 10의 개수가 나오고 그거 리턴해주면 될듯함
        // return Math.min(n/5,n/2);
        //  n = 30  일때 내 아웃풋은 6인데 답은 7임
        // 30*29*28*27*26*25*24*23*22*21*20*19*18*17*16*15*14*13*12*11*10*9*8*7*6*5*4*3*2*1
        // 5,2   2.   2.  5.  2.  2.   2.5.    2.   2. 5. 2.   2.     5 2  2.  2.  5  2. 2 
        // 5: 30, 25, 20, 15, 10, 5
        // 2: 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2
        // 왜지?
        // 하하 25에는 5가 두번 들어감~ 
        // 5의 제곱들을 보면 숫자를 추가해줘야
        // 2는 반드시 5보다 개수가 많으니까 제곱근 체크 안 해줘도 될 것 같다~
        // 25: +1 , 125: +2, 625: +3, ... -> 이게 또 등차수열이잖아? 4+3+2+1
        // n = 가장 가까운 5의 몇승; int extra = (n+1)/2*n;
        int five = n/5;
        // 문제: n = 가장 가까운 5의 몇승을 어떻게 구할 것인가
        // 나의 의견: 이분탐색을 하면 빠르지 않을까 싶다
        // 0 <= n <= 10^4
        for(int i=25; i<=n; i=i*5){
            five += n/i;
        }
        return five;
    }
}